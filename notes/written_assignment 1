What in the reading list resonates the most with you? Pick up to 10 most useful tips/top takeaways you would recommend to other programmers or you would like to remember. Summarise in one liners (optionally with a short quote or summary after it and stating its source). Keep the write-up to within one page.

1. Code should be written to minimize the time it would take for someone else to read it (http://stephenhouser.com/blog/2013/02-15-the-art-of-readable-code.html) - Coding in the real-world often requires collaboration between multiple software engineers and that entails having to understand each others code (minimally the flow of the code, input and output for each function). Therefore, it is of utmost importance to write readable code so that when others review your code, they will be able understand what your code is trying to do. Some examples to make your code readable can be in the form of type-hinting to allow others to understand the input and output of your functions, using variable names that are informative and meaningful as compared to using variable names like (i = 0, s_h=y[0]).

2. Let one function or method perform only one task (https://blog.alexdevero.com/6-simple-tips-writing-clean-code/) - Having functions that performs a single task allows for better modularization, and cleaner code. Also, by not over-complicating each function, it will be easier to debug your code when something goes wrong as you can more easily pinpoint the function(task) that was causing the error.

3. Use comments for clarification (https://blog.alexdevero.com/6-simple-tips-writing-clean-code/) - Sometimes, even when abiding to good coding practices, when the number of functions increases in a code base or the task in a function is too complex, it is good practice to add in comments to your code to break down functions to more explainable small parts for understanding. 

4. Understand your coverage of code and functionality (https://testing.googleblog.com/) - Testing is always an important part of software engineering, and code coverage is an important measure of the degree to which the source code of a program is executed when a particular test suite is run. It is important to understand the coverage of your code as A program with high test coverage has more of its source code executed during testing, which suggests it has a lower chance of containing undetected software bugs compared to a program with low test coverage. 

5. Tests at every level of the hierarchy (https://www.lihaoyi.com/post/PrinciplesofAutomatedTesting.html) - Every piece of software is written hierarchically, as units integrating smaller units. Therefore, you cannot have only solely unit tests or solely intergration tests when performing testing on your code. Your should structure your code in a way that tests all levels of your code to prevent the possibility for errors to be introduced at any level in the hierarchy.

6. Prioritize tests (https://www.lihaoyi.com/post/PrinciplesofAutomatedTesting.html) - Testing during a software development lifecycle results in costs for the team as someone has to write them and run them. Therefore, it is important to prioritize what kind of tests to run, and what are the more important features in the software to test.

7. Code reviews suck less when the process is clear (https://trishagee.github.io/presentation/code_review_best_practice/) - When the team has a clear process of code review, code reviews will be "less painful and suck less" as everyone in the team will know what to look for in a code review, and how to go about doing it. Only by having a clear code review process, can the team effectively perform code reviews.

8. Pair programmming allows us to discuss approaches and solutions (https://martinfowler.com/articles/on-pair-programming.html) - Pair prgramming allow us to have a second opinion on the task or problem we are trying to solve. By discussing the approaches and solutions to a problem with another colleague allow us to reflect if we really have the right understanding, or if we really have a good solution.

9. Measuring understadability using Cognitive Complexity (https://www.sonarsource.com/docs/CognitiveComplexity.pdf) - Cognitive Complexity breaks from the practice of using mathematical models to assess
software maintainability. It uses human judgment to assess how structures should be counted, and to decide what should be added to the model as a whole. As a result, it yields method complexity scores which strike programmers as fairer relative assessments of understandability than have been available with previous models.

10. Updating documentation (https://abseil.io/resources/swe-book/html/ch03.html#documentation-id00039) - More often than not, we are required to hand-over/take-over code from other teammates and documenting your procedures can help you save time in the future by pointing team members to the documentation and providing hands-on help only when needed. Information in the documentation becomes canonicalized as a reference: team members can refer to the shared document and even update it themselves

